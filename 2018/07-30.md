## OSS

### c3js/c3

- [pull #2439](https://github.com/c3js/c3/pull/2439)
  - チャートの横の範囲をドラッグするとその範囲にチャートがズームするという[機能](https://468-11496279-gh.circle-artifacts.com/0/htdocs/samples/zoom_type.html)が [pull #1500](https://github.com/c3js/c3/pull/1500) で提案されていて(コレ自体は自分がメンテナになるはるか以前), 一旦レビューOKになったもののその後放置し過ぎた結果マージできなくなっていたのを, マージ可能に修正するというPR. d3-brush というモジュールを使って選択範囲のようなものを出しているのだけど, d3 v3系と v4系以上で API がかなり変わっていたため, かなり直す必要があった. 改めて d3 はかなり辛いという印象が強くなった.

### ry/deno

- 今週もかなり活発な deno. option parse は2転3転して, やっぱり js でやりましょうという話になって(rust では --v8-options など非常に限定的な option のみ扱う), js でどの parser 使うかというのも2転3転したのち minimist2 という typescript で書き直された minimist が組み込み中.
- setTimeout の実装も進んでいて, rust の非同期ライブラリの tokio が導入されている.
- ビルドツール周りも整備が進んで repo をクローンしてから `./tools/setup.py` `./tools/build.py` でビルド出来るようになった.

## MyProject

### kt3k/saku

- [pull #31](https://github.com/kt3k/saku/issues/31)
  - タスクのグルーピングを実装する PR. golang が久しぶりだったので, 自分の実装をキャッチアップするのに少し時間がかかったものの, テストカバレッジ(C1)が100%なので, 落ち着いて自由気ままにリファクタリングをしていたら golang 熱が戻ってきた.
  - 実装上ネックになった部分は主に2点で, タスクの各ノードの実行開始を goroutine に通知して別スレッドでログ出力する実装でやろうとしたのだけど, ログが出るタイミングとコマンドの中身が実行されるタイミングがうまく制御できなかった(タスク開始のログより先にコマンドの中の出力が出力されてしまう(時系列と逆)事があった)点. 結局 goroutine に通知する実装を諦めて, 愚直にメインスレッドでログ出力するように書き換えた. もう1点は blackfriday (markdown parser) の parse が非常に分かりにくかった点. `<!-- saku parallel -->` というディレクティブを markdown の中に書くとそのタスクの子タスク達は parallel に実行されるという機能を実装してる時に, `<!-- saku parallel -->` が入っているノードを blackfriday のツリーから見つけ出すのが非常に時間がかかった. 例えば, js の場合だと parse された object をそのまま dump すれば何がどこにあるか眺めるだけで解決する事が, blackfriday の場合だと, そもそも blackfriday が何をどう parse しているのかを知るために大量のコードを書かなければならず, 非常に不効率で時間がかかってしまった.
  - 実装をしていて面白かった点は, 機能を実装し終わった後に, さらにリファクタリングを進めていた時に, js 版の実装とは違う方向性の抽象化が必要になった点が面白かった. JS では parse された option を使って CLI がどのアクションを dispatch するか, という部分を抽象化するために, [action-selector](https://www.npmjs.com/package/action-selector) というモジュールを作っていて, minimist 後, 各アクションに入るつなぎまでの部分をやるものという感じで抽象化しているのだけど, golang だとそもそもコレと同じことをするものを実装しようとしてもうまくいかず, 代わりに option を parse した object をラップした, 流暢なインターフェースの option オブジェクトのようなものを実装したところうまく行ったという点が面白かった. 改めて2つの抽象化を見比べてみると, golang の抽象化の方が堅牢でうまく行っているように見えて, js の抽象化は幼稚な API という印象に映る. golang のように本当にシンプルな機能しか持っていない言語で書く事で, 本来あるべき抽象化の方向と, js の柔軟すぎる言語仕様のゆえに実現できている特殊な抽象化の仕方の違いが炙り出されるのが面白いと思った.

## 仕事

### flowtype 集団信号無視事件

- とある flowtype の入ったプロジェクトにコミットしようとしたらなぜか flow チェックが全く通らず, エラーの箇所も自分の変更箇所と全く関係ない箇所から大量に出ており, どうも flow が通るかどうかを全くチェックしないまま開発しているらしいという事が発覚. そういえば, flow を入れているチームが多いはずなのに flow の型チェックが通らなくて困ったという話題が全く聞こえて来ないような気がして, 各チームを監視しに行ったところ, 計3チームが flow を導入しつつ flow チェックをしていない事が分かり, それらの放置されたエラー (計400程度) を片っ端から修正し, CI でもチェックするようにするという修正を行った.

### greenkeeper-lockfile

- [redux-pluto pull #111](https://github.com/recruit-tech/redux-pluto/pull/111)
  - [greenkeeper](https://greenkeeper.io/) に yarn.lock や package-lock.json を自動的にアップデートさせるためのスクリプトで [greenkeeper-lockfile](https://github.com/greenkeeperio/greenkeeper-lockfile) というものがあるが, これを circleci できちんと動かすようにするという修正. このスクリプト自体は大した仕事をしていなくて, greenkeeper のコミットで npm install した結果 lock ファイルに差分が出たらそれを追加でコミットするというだけなのだが, その greenkeeper のコミットで, という仮定の部分が異常に厳しく, 具体的に何をチェックしているのかドキュメントもされておらず, エラーメッセージからも次のアクションが分からないため, ソースコードをかなり読み込んで, 何がどうなっているかを把握しながら circleci のコンフィグをかなり書き換える必要があった. 途中ブランチの最初のビルド以外は無効になるという仕様がある事が分かり, それ以降は1つ試すごとに1ブランチ作るという PDCA を回す必要があったため, 最終的に10ブランチ目5プルリク目でやっと成功した.
